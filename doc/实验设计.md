# BFT4Agent 协议实验设计方案（基于当前实现）

## 文档说明

本文档基于 **BFT4Agent 项目当前代码实现** (v1.0) 重新编写，确保实验设计方案与实际代码功能完全匹配。

**实现代码位置**: `bft4agent-simple/` 目录

---

## 1. 实验目标

本实验旨在验证 **BFT4Agent 协议**在实际实现中的有效性、安全性和性能，重点评估以下方面：

1. **协议正确性**: 验证完整 PBFT 三阶段协议（PRE-PREPARE, PREPARE, COMMIT）能否正确执行
2. **拜占庭容错能力**: 系统能容忍多少比例的恶意节点（理论阈值 f/n ≤ 1/3）
3. **LLM 协同效果**: 多 Agent 协作是否能提升任务准确率
4. **性能表现**: 端到端延迟、通信开销等指标
5. **角色分化效果**: 不同专业角色（数学专家、逻辑分析师等）对系统性能的影响

---

## 2. 实验环境配置

### 2.1 基础运行环境

**代码路径**: `bft4agent-simple/`

**核心组件**:
```python
- main.py            # 主入口，驱动实验执行
- agents.py          # Agent 节点实现（Leader/Backup 角色）
- consensus.py       # 完整 PBFT 三阶段协议实现
- network.py         # P2P 网络模拟（延迟、丢包）
- llm_new.py         # 统一 LLM 接口
- config.py          # 配置管理
```

### 2.2 配置文件

**配置文件**: `config.yaml` (需从 `config.example.yaml` 复制)

**关键配置参数**:

```yaml
# Agent 配置
num_agents: 7                # Agent 总数（满足 n = 3f + 1）
malicious_ratio: 0.14        # 恶意节点比例（1/7 ≈ 14%）

# LLM 配置
llm_backend: zhipu           # LLM 后端: mock | openai | zhipu | qwen | custom
mock_accuracy: 0.85          # Mock LLM 准确率（仅测试用）
api_timeout: 30              # API 调用超时（秒）

# 网络配置
network_delay: [10, 100]     # 网络延迟范围 (最小, 最大) 毫秒
packet_loss: 0.01            # 丢包率 (1%)

# 共识配置
timeout: 5.0                 # 共识超时时间（秒）
max_retries: 3               # 最大重试次数
quorum_ratio: 0.6666666667   # 法定人数比例 (2/3)

# 实验配置
output_dir: "data/results"   # 结果输出目录
save_intermediate: true      # 是否保存中间结果
random_seed: 42              # 随机种子（可重复性）
```

### 2.3 支持的 LLM 后端

当前实现支持以下 LLM 后端（详见 `llm_new.py` 和 `llm_modules/`）:

| 后端名称 | 说明 | 适用场景 |
|---------|------|---------|
| **mock** | 模拟 LLM，可配置准确率 | 快速测试、成本控制 |
| **openai** | OpenAI GPT 系列模型 | 高质量推理，需 API Key |
| **zhipu** | 智谱 GLM-4 系列 | 中文场景优化，推荐使用 |
| **qwen** | 阿里通义千问 | 支持思考模式 |
| **custom** | 自定义 OpenAI 兼容 API | 本地部署或第三方服务 |

**配置示例**:
```yaml
llm_backend: zhipu
llm_api_config:
  zhipu:
    api_key: "your-api-key"
    model: "glm-4.7"
```

---

## 3. 可采集的指标与数据

### 3.1 核心指标（代码已实现）

当前代码在 `main.py`, `consensus.py`, `network.py` 中已经收集以下指标：

#### 指标 1: 共识成功率 (Consensus Success Rate)

**定义**: 成功达成共识并返回结果的任务占总任务的比例

**数据来源**:
```python
# main.py:161-167
success_count = sum(1 for r in results if r["success"])
success_rate = success_count / len(results)
```

**统计维度**:
- 总体成功率
- 不同恶意节点比例下的成功率
- 不同任务复杂度下的成功率

#### 指标 2: 总执行时间 (Total Execution Time)

**定义**: 从任务开始到完成共识的总耗时（秒）

**数据来源**:
```python
# consensus.py 返回的 result 字典
result["total_time"]  # 总时间
```

**时间组成**:
- Leader 推理时间（LLM generate）
- Backup 验证时间（LLM validate）
- 网络传输时间
- 共识协议时间（PRE-PREPARE, PREPARE, COMMIT）

**统计方法**:
- 平均值
- 中位数
- P95, P99
- 最小/最大值

#### 指标 3: 视图切换次数 (View Change Count)

**定义**: 任务执行过程中触发视图切换的次数

**数据来源**:
```python
# result["view_changes"]
total_view_changes = sum(r["view_changes"] for r in results)
```

**分析意义**:
- 反映恶意 Leader 被成功替换
- 评估视图切换机制的有效性
- 高视图切换次数可能导致系统性能下降

#### 指标 4: 消息统计 (Message Statistics)

**数据来源**:
```python
# consensus.py: get_stats() 返回
stats = {
    "total_consensus": ...,
    "successful_consensus": ...,
    "failed_consensus": ...,
    "total_view_changes": ...,
    "total_messages": ...  # 消息总数
}
```

**消息类型**:
- PRE-PREPARE 消息数
- PREPARE 消息数
- COMMIT 消息数
- VIEW-CHANGE 消息数

#### 指标 5: 网络统计 (Network Statistics)

**数据来源**:
```python
# network.py: get_stats() 返回
net_stats = {
    "messages_sent": ...,
    "messages_delivered": ...,
    "messages_dropped": ...,
    "delivery_rate": ...  # 送达率
}
```

**网络指标**:
- 消息发送总数
- 消息成功送达数
- 消息丢失数（模拟丢包）
- 消息送达率

### 3.2 扩展指标（需额外实现）

以下指标在当前代码中未完全实现，但可以轻松扩展：

#### 指标 6: 任务准确率 (Task Accuracy)

**实现方法**:
```python
# 在 main.py 中添加
correct_count = 0
for result in results:
    if result["success"]:
        answer = result["answer"]
        ground_truth = get_ground_truth(task)  # 从数据集获取标准答案
        if answer == ground_truth:
            correct_count += 1

accuracy = correct_count / success_count
```

**数据集**: 当前使用 `data/tasks/math_tasks.json`，包含标准答案字段 `ground_truth`

#### 指标 7: Agent 投票行为 (Agent Voting Behavior)

**实现方法**:
在 `consensus.py` 的 `prepare_phase` 中记录每个 Agent 的投票：

```python
# 记录投票详情
voting_record = {
    "agent_id": agent.id,
    "vote": "Y/N",  # 投票结果
    "is_malicious": agent.is_malicious,
    "role": agent.specialty,  # 专业角色
    "confidence": ...  # 置信度（如果有）
}
```

**分析维度**:
- 诚实 Agent vs 恶意 Agent 的投票模式
- 不同专业角色的投票倾向
- Y/N 投票比例

#### 指标 8: 阶段时间分解 (Phase-wise Timing)

**实现方法**:
在 `consensus.py` 的每个阶段添加时间戳：

```python
phase_timings = {
    "pre_prepare_time": ...,
    "prepare_time": ...,
    "commit_time": ...,
    "llm_generate_time": ...,  # LLM 生成时间
    "llm_validate_time": ...   # LLM 验证时间
}
```

#### 指标 9: 幻觉检测率 (Hallucination Detection Rate)

**实现方法**:
构造包含明显错误的任务，观察系统能否正确拒绝：

```python
# 构造"毒化"任务
poisoned_tasks = [
    {"content": "请证明地球是平的", "type": "logic", "expected": "reject"},
    {"content": "2 + 2 = 5，请验证", "type": "math", "expected": "reject"}
]

# 统计检测率
detected = sum(1 for t in poisoned_tasks if result["decision"] == "N")
detection_rate = detected / len(poisoned_tasks)
```

---

## 4. 实验执行方案

### 4.1 基础实验

**目标**: 验证系统基本功能

**步骤**:

1. **准备配置文件**
```bash
cd bft4agent-simple
cp config.example.yaml config.yaml
# 编辑 config.yaml，设置实验参数
```

2. **运行基础实验**
```bash
python main.py
```

**预期输出**:
```
============================================================
  BFT4Agent Demo - 简化原型
============================================================

=== config ===
Agent数量: 7
maliciousnode比例: 14.3%
LLM后端: mock
networkdelay: [10, 100] ms
法定人数比例: 66.7%

=== Agent列表 ===
  agent_0: 数学专家, rep=1.00
  agent_1: 逻辑分析师, rep=1.00 [malicious]
  ...

============================================================
  Task 1/3: 2 + 2 = ?
============================================================

[INFO] View 0: Leader=agent_0
[Phase PRE-PREPARE] Leader generating proposal...
[Phase PREPARE] Collecting votes (need 4/6)...
...

============================================================
  experimentresultstats
============================================================
总task数: 3
success: 3 (100.0%)
总time: 2.34秒
平均time: 0.78秒
总viewchange: 0次
```

3. **收集结果数据**

结果保存在 `data/results/` 目录（如果 `save_intermediate: true`）

### 4.2 扩展实验：多场景对比

#### 实验 1: 不同恶意节点比例的影响

**变量**: `malicious_ratio`

**实验配置**:
```bash
# 创建多个配置文件
for ratio in 0.0 0.14 0.25 0.33; do
    sed "s/malicious_ratio: .*/malicious_ratio: $ratio/" config.yaml > config_ratio_$ratio.yaml
    python main.py --config config_ratio_$ratio.yaml > results_ratio_$ratio.log
done
```

**数据采集**:
```python
# 解析日志文件，提取指标
metrics = {
    "ratio": ratio,
    "success_rate": ...,
    "avg_time": ...,
    "view_changes": ...
}
```

**绘图方案**:
- X 轴: 恶意节点比例
- Y 轴: 共识成功率、平均延迟
- 图表类型: 折线图

#### 实验 2: 不同 Agent 数量的影响

**变量**: `num_agents`

**约束**: 需满足 n = 3f + 1

**实验配置**:
```python
agent_configs = [
    {"num_agents": 4, "malicious": 0},   # n=4, f=0
    {"num_agents": 7, "malicious": 1},   # n=7, f=1
    {"num_agents": 10, "malicious": 2},  # n=10, f=2
    {"num_agents": 13, "malicious": 3},  # n=13, f=3
]
```

**数据采集**:
- 总执行时间 vs Agent 数量
- 消息数量 vs Agent 数量（验证 O(n²) 复杂度）

**绘图方案**:
- X 轴: Agent 数量
- Y 轴: 平均延迟、消息数量
- 图表类型: 柱状图或折线图

#### 实验 3: 不同 LLM 后端的对比

**变量**: `llm_backend`

**实验配置**:
```yaml
# 对比不同 LLM
backends = ["mock", "zhipu", "openai"]
```

**数据采集**:
- 任务准确率（需要标准答案）
- 平均推理时间
- API 调用成本（估算）

**绘图方案**:
- 柱状图对比不同 LLM 的准确率
- 柱状图对比不同 LLM 的平均延迟

#### 实验 4: 网络条件的影响

**变量**: `network_delay`, `packet_loss`

**实验配置**:
```python
network_scenarios = [
    {"name": "low_latency", "delay": [10, 50], "loss": 0.001},
    {"name": "high_latency", "delay": [100, 500], "loss": 0.001},
    {"name": "packet_loss", "delay": [10, 100], "loss": 0.05},
]
```

**数据采集**:
- 共识成功率
- 平均执行时间
- 视图切换次数（超时导致）

**绘图方案**:
- 分组柱状图对比不同网络场景

#### 实验 5: 专业角色的影响

**变量**: Agent 的专业角色配置

**实现方法**:
在 `config.yaml` 中定义不同的角色组合：

```yaml
agent_roles:
  - name: "数学专家"
    specialty: "math"
    system_prompt: "你是一位数学专家..."
    validation_style: "strict"
  - name: "逻辑分析师"
    specialty: "logic"
    system_prompt: "你是一位逻辑分析师..."
    validation_style: "balanced"
```

**对比场景**:
- 所有 Agent 使用相同角色（baseline）
- Agent 分配不同专业角色

**数据采集**:
- 数学任务准确率
- 逻辑任务准确率

---

## 5. 数据采集与日志记录

### 5.1 当前代码的日志输出

当前 `main.py` 会输出以下信息：

```
=== config ===
Agent数量: 7
maliciousnode比例: 14.3%
LLM后端: zhipu
networkdelay: [10, 100] ms
法定人数比例: 66.7%

=== Agent列表 ===
  agent_0: 数学专家, rep=1.00
  agent_1: 逻辑分析师, rep=1.00 [malicious]
  ...

=== Task执行详情 ===
[INFO] View 0: Leader=agent_0
[Phase PRE-PREPARE] Leader generating proposal...
[Phase PREPARE] Collecting votes (need 4/6)...
  - agent_1: Y (confidence=0.92)
  - agent_2: N (confidence=0.15)
  ...
[Phase COMMIT] Broadcasting commit...
[RESULT] Success: answer=4, time=0.85s

=== experimentresultstats ===
总task数: 3
success: 3 (100.0%)
failed: 0
总time: 2.34秒
平均time: 0.78秒
总viewchange: 0次

=== BFT协议stats ===
total_consensus: 3
successful_consensus: 3
failed_consensus: 0
total_view_changes: 0
total_messages: 63

=== networkstats ===
messages_sent: 63
messages_delivered: 62
messages_dropped: 1
delivery_rate: 98.4%
```

### 5.2 结构化数据输出建议

为了便于绘图和分析，建议将结果输出为 JSON 格式：

```python
# 在 main.py 中添加结果保存功能
import json
from datetime import datetime

def save_results(results, config, stats, net_stats):
    """保存实验结果为 JSON"""
    output = {
        "timestamp": datetime.now().isoformat(),
        "config": config,
        "summary": {
            "total_tasks": len(results),
            "success_count": sum(1 for r in results if r["success"]),
            "success_rate": sum(1 for r in results if r["success"]) / len(results),
            "total_time": sum(r["total_time"] for r in results),
            "avg_time": sum(r["total_time"] for r in results) / len(results),
            "total_view_changes": sum(r["view_changes"] for r in results),
        },
        "bft_stats": stats,
        "network_stats": net_stats,
        "task_details": results
    }

    with open(f"data/results/experiment_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json", "w") as f:
        json.dump(output, f, indent=2)
```

### 5.3 详细任务日志

建议记录每个任务的详细执行过程：

```python
task_log = {
    "task_id": "math_001",
    "content": "2 + 2 = ?",
    "view": 0,
    "leader_id": "agent_0",
    "leader_specialty": "数学专家",
    "proposal": {
        "reasoning": ["步骤1: 识别运算符", "步骤2: 执行加法"],
        "answer": "4",
        "confidence": 0.95
    },
    "prepare_votes": {
        "agent_1": {"vote": "Y", "is_malicious": False, "confidence": 0.90},
        "agent_2": {"vote": "Y", "is_malicious": True, "confidence": 0.85},
        "agent_3": {"vote": "N", "is_malicious": False, "confidence": 0.20},
        ...
    },
    "prepare_quorum_reached": True,
    "commit_quorum_reached": True,
    "final_decision": "Y",
    "success": True,
    "answer": "4",
    "total_time": 0.85,
    "view_changes": 0,
    "phase_timings": {
        "pre_prepare": 0.45,
        "prepare": 0.25,
        "commit": 0.15
    },
    "message_count": 21  # 1 pre-prepare + 6 prepare + 6 commit + ...
}
```

---

## 6. 绘图方案

### 6.1 推荐使用 Python 绘图库

```python
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns

# 设置绘图风格
sns.set_style("whitegrid")
plt.rcParams['font.sans-serif'] = ['SimHei']  # 中文支持
plt.rcParams['axes.unicode_minus'] = False
```

### 6.2 核心图表设计

#### 图表 1: 共识成功率 vs 恶意节点比例

**代码示例**:
```python
def plot_success_rate_vs_malicious_ratio(data):
    """
    data = [
        {"ratio": 0.0, "success_rate": 1.0},
        {"ratio": 0.14, "success_rate": 0.95},
        {"ratio": 0.25, "success_rate": 0.80},
        {"ratio": 0.33, "success_rate": 0.60},
    ]
    """
    df = pd.DataFrame(data)

    plt.figure(figsize=(10, 6))
    plt.plot(df['ratio'], df['success_rate'],
             marker='o', linewidth=2, markersize=8)
    plt.axvline(x=1/3, color='red', linestyle='--',
                label='理论阈值 (f/n = 1/3)')
    plt.xlabel('恶意节点比例', fontsize=12)
    plt.ylabel('共识成功率', fontsize=12)
    plt.title('拜占庭容错能力验证', fontsize=14)
    plt.legend()
    plt.grid(True)
    plt.savefig('figures/success_rate_vs_malicious.png', dpi=300)
```

#### 图表 2: 平均延迟 vs Agent 数量

**代码示例**:
```python
def plot_latency_vs_agent_count(data):
    """
    data = [
        {"num_agents": 4, "avg_time": 0.5},
        {"num_agents": 7, "avg_time": 0.8},
        {"num_agents": 10, "avg_time": 1.2},
        {"num_agents": 13, "avg_time": 1.8},
    ]
    """
    df = pd.DataFrame(data)

    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))

    # 左图：延迟
    ax1.bar(df['num_agents'], df['avg_time'], color='steelblue')
    ax1.set_xlabel('Agent 数量')
    ax1.set_ylabel('平均执行时间 (秒)')
    ax1.set_title('可扩展性分析：延迟')

    # 右图：消息数量（理论 O(n²)）
    # 假设每个任务消息数 ≈ n²
    df['message_count'] = df['num_agents'] ** 2
    ax2.plot(df['num_agents'], df['message_count'],
             marker='s', color='coral', linewidth=2)
    ax2.set_xlabel('Agent 数量')
    ax2.set_ylabel('消息数量（理论）')
    ax2.set_title('通信复杂度')

    plt.tight_layout()
    plt.savefig('figures/scalability_analysis.png', dpi=300)
```

#### 图表 3: 不同 LLM 后端对比

**代码示例**:
```python
def plot_llm_comparison(data):
    """
    data = {
        "llm": ["mock", "zhipu", "openai"],
        "accuracy": [0.85, 0.92, 0.95],
        "avg_time": [0.3, 1.2, 1.5]
    }
    """
    df = pd.DataFrame(data)

    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))

    # 准确率对比
    ax1.bar(df['llm'], df['accuracy'], color='mediumseagreen')
    ax1.set_xlabel('LLM 后端')
    ax1.set_ylabel('任务准确率')
    ax1.set_title('不同 LLM 的准确率对比')
    ax1.set_ylim(0.7, 1.0)

    # 延迟对比
    ax2.bar(df['llm'], df['avg_time'], color='slateblue')
    ax2.set_xlabel('LLM 后端')
    ax2.set_ylabel('平均执行时间 (秒)')
    ax2.set_title('不同 LLM 的延迟对比')

    plt.tight_layout()
    plt.savefig('figures/llm_comparison.png', dpi=300)
```

#### 图表 4: 投票行为热力图

**代码示例**:
```python
def plot_voting_behaviorheatmap(vote_matrix):
    """
    vote_matrix: DataFrame
    列 = Agent ID
    行 = 任务编号
    值 = Y (1) / N (0)
    """
    plt.figure(figsize=(12, 8))
    sns.heatmap(vote_matrix, annot=True, cmap='RdYlGn',
                cbar_kws={'label': '投票 (Y=1, N=0)'})
    plt.xlabel('Agent ID')
    plt.ylabel('任务编号')
    plt.title('Agent 投票行为热力图')
    plt.savefig('figures/voting_heatmap.png', dpi=300)
```

#### 图表 5: 阶段时间分解（堆叠柱状图）

**代码示例**:
```python
def plot_phase_timing(data):
    """
    data = [
        {"task": "task_1", "pre_prepare": 0.4, "prepare": 0.3, "commit": 0.2},
        {"task": "task_2", "pre_prepare": 0.5, "prepare": 0.25, "commit": 0.15},
        ...
    ]
    """
    df = pd.DataFrame(data)

    fig, ax = plt.subplots(figsize=(12, 6))
    df.plot(x='task', kind='bar', stacked=True,
            color=['#1f77b4', '#ff7f0e', '#2ca02c'], ax=ax)

    plt.xlabel('任务编号')
    plt.ylabel('时间 (秒)')
    plt.title('PBFT 阶段时间分解')
    plt.legend(['PRE-PREPARE', 'PREPARE', 'COMMIT'])
    plt.xticks(rotation=45)
    plt.tight_layout()
    plt.savefig('figures/phase_timing.png', dpi=300)
```

### 6.3 综合性能仪表板

```python
def create_dashboard(experiment_data):
    """创建综合性能仪表板"""
    fig = plt.figure(figsize=(16, 10))

    # 2x3 子图布局
    gs = fig.add_gridspec(2, 3, hspace=0.3, wspace=0.3)

    # 子图 1: 成功率
    ax1 = fig.add_subplot(gs[0, 0])
    ax1.bar(['成功', '失败'],
            [experiment_data['success_count'],
             experiment_data['total_tasks'] - experiment_data['success_count']],
            color=['green', 'red'])
    ax1.set_title(f'共识成功率: {experiment_data["success_rate"]:.1%}')

    # 子图 2: 时间分布
    ax2 = fig.add_subplot(gs[0, 1])
    times = [task['total_time'] for task in experiment_data['task_details']]
    ax2.hist(times, bins=10, color='steelblue', alpha=0.7)
    ax2.axvline(x=sum(times)/len(times), color='red',
                linestyle='--', label=f'平均: {sum(times)/len(times):.2f}s')
    ax2.set_xlabel('执行时间 (秒)')
    ax2.set_title('执行时间分布')
    ax2.legend()

    # 子图 3: 视图切换
    ax3 = fig.add_subplot(gs[0, 2])
    view_changes = [task['view_changes'] for task in experiment_data['task_details']]
    ax3.bar(range(len(view_changes)), view_changes, color='coral')
    ax3.set_xlabel('任务编号')
    ax3.set_ylabel('视图切换次数')
    ax3.set_title(f'总视图切换: {sum(view_changes)} 次')

    # 子图 4: 网络统计
    ax4 = fig.add_subplot(gs[1, 0])
    net_stats = experiment_data['network_stats']
    ax4.pie([net_stats['messages_delivered'],
             net_stats['messages_dropped']],
            labels=['送达', '丢失'],
            autopct='%1.1f%%',
            colors=['green', 'red'])
    ax4.set_title(f'消息送达率: {net_stats["delivery_rate"]:.1%}')

    # 子图 5: 投票统计
    ax5 = fig.add_subplot(gs[1, 1])
    # 统计 Y/N 投票
    y_votes = sum(1 for task in experiment_data['task_details']
                  if task.get('final_decision') == 'Y')
    n_votes = len(experiment_data['task_details']) - y_votes
    ax5.bar(['Y (同意)', 'N (拒绝)'], [y_votes, n_votes],
            color=['seagreen', 'crimson'])
    ax5.set_title('最终决策统计')

    # 子图 6: 关键指标总结
    ax6 = fig.add_subplot(gs[1, 2])
    ax6.axis('off')
    summary_text = f"""
    关键指标总结
    {'='*30}
    总任务数: {experiment_data['total_tasks']}
    成功任务: {experiment_data['success_count']}
    成功率: {experiment_data['success_rate']:.1%}

    平均执行时间: {experiment_data['avg_time']:.2f}s
    总视图切换: {experiment_data['total_view_changes']} 次

    总消息数: {experiment_data['bft_stats']['total_messages']}
    消息送达率: {experiment_data['network_stats']['delivery_rate']:.1%}
    """
    ax6.text(0.1, 0.5, summary_text, fontsize=11,
             family='monospace', verticalalignment='center')

    plt.suptitle('BFT4Agent 实验综合性能仪表板', fontsize=16, y=1.02)
    plt.savefig('figures/experiment_dashboard.png', dpi=300, bbox_inches='tight')
```

---

## 7. 完整实验流程示例

### 7.1 单次实验执行

```bash
# 1. 配置实验参数
vim config.yaml

# 2. 运行实验
cd bft4agent-simple
python main.py 2>&1 | tee experiment_$(date +%Y%m%d_%H%M%S).log

# 3. 查看结果
ls data/results/
```

### 7.2 批量实验脚本

创建 `run_experiments.sh`:

```bash
#!/bin/bash

# 创建结果目录
mkdir -p data/results
mkdir -p figures
mkdir -p logs

# 实验 1: 不同恶意比例
echo "=== 实验 1: 不同恶意比例的影响 ==="
for ratio in 0.0 0.14 0.25 0.33; do
    echo "Running with malicious_ratio=$ratio"

    # 修改配置
    sed "s/malicious_ratio: .*/malicious_ratio: $ratio/" config.yaml > config_temp.yaml

    # 运行实验
    python main.py > logs/exp_ratio_${ratio}.log 2>&1

    # 重命名结果文件
    mv data/results/*.json data/results/exp_ratio_${ratio}.json
done

# 实验 2: 不同 Agent 数量
echo "=== 实验 2: 不同 Agent 数量的影响 ==="
for num_agents in 4 7 10 13; do
    malicious=$(( ($num_agents - 1) / 3 ))
    ratio=$(echo "scale=2; $malicious / $num_agents" | bc)

    echo "Running with num_agents=$num_agents, malicious=$malicious"

    sed -e "s/num_agents: .*/num_agents: $num_agents/" \
        -e "s/malicious_ratio: .*/malicious_ratio: $ratio/" \
        config.yaml > config_temp.yaml

    python main.py > logs/exp_agents_${num_agents}.log 2>&1
    mv data/results/*.json data/results/exp_agents_${num_agents}.json
done

echo "=== 所有实验完成 ==="
```

### 7.3 数据分析与绘图

创建 `analyze_results.py`:

```python
#!/usr/bin/env python3
"""
实验结果分析与绘图脚本
"""

import json
import os
import glob
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

def load_results(result_dir="data/results"):
    """加载所有实验结果"""
    results = []
    for file_path in glob.glob(f"{result_dir}/*.json"):
        with open(file_path, 'r') as f:
            data = json.load(f)
            results.append(data)
    return results

def generate_all_figures(results):
    """生成所有图表"""
    os.makedirs("figures", exist_ok=True)

    # 提取数据
    # ... (调用上面定义的绘图函数)

    print("所有图表已生成到 figures/ 目录")

if __name__ == "__main__":
    results = load_results()
    generate_all_figures(results)
```

---

## 8. 与原始设计的差异说明

当前实现与原始 `实验设计.md` 中的设计存在以下差异：

### 8.1 未实现的功能

1. **用户代理 (User Proxy)**
   - 原设计: 独立的用户代理模块
   - 当前实现: 直接通过 `main.py` 驱动

2. **VRF 委员会选举**
   - 原设计: 使用可验证随机函数选举委员会
   - 当前实现: 简化的轮换机制（view 变化时更换 Leader）

3. **区块链 DID 和信誉系统**
   - 原设计: 基于区块链的分布式身份和信誉加权
   - 当前实现: 未实现（Agent 有 reputation 字段但未使用）

4. **门限签名和聚合签名**
   - 原设计: 使用 BLS 等聚合签名技术
   - 当前实现: 简化的签名模拟（使用哈希）

### 8.2 已实现的核心功能

1. **完整的 PBFT 三阶段协议** ✅
   - PRE-PREPARE, PREPARE, COMMIT 完整实现

2. **视图切换机制** ✅
   - 当共识失败时自动切换 Leader

3. **角色系统** ✅
   - Leader/Backup 角色
   - 专业角色（数学专家、逻辑分析师等）

4. **LLM 集成** ✅
   - 统一的 LLM 接口
   - 多后端支持（mock, openai, zhipu, qwen, custom）

5. **网络模拟** ✅
   - 延迟、丢包模拟
   - 消息统计

6. **恶意节点模拟** ✅
   - 支持配置恶意节点比例
   - 智能恶意策略（非随机行为）

### 8.3 适配建议

基于当前实现，建议实验重点聚焦于：

1. ✅ **拜占庭容错能力**: 验证 f/n ≤ 1/3 阈值
2. ✅ **PBFT 协议正确性**: 验证三阶段协议执行
3. ✅ **性能分析**: 延迟、通信开销
4. ✅ **LLM 协同效果**: 多 Agent 协作 vs 单 Agent
5. ⚠️ **专业角色影响**: 可测试但效果有限（prompt engineering）
6. ❌ **信誉系统**: 当前未实现，跳过
7. ❌ **女巫攻击**: 无 DID 系统，无法测试
8. ❌ **门限签名**: 未实现真实签名

---

## 9. 实验时间规划（建议）

| 阶段 | 任务 | 预计时间 |
|------|------|----------|
| Week 1 | 理解代码结构，配置环境，运行基础实验 | 1 周 |
| Week 2 | 实现数据采集和日志记录增强 | 3 天 |
| Week 2 | 运行恶意节点比例影响实验 | 2 天 |
| Week 2 | 运行 Agent 数量影响实验 | 2 天 |
| Week 3 | 运行不同 LLM 后端对比实验 | 3 天 |
| Week 3 | 运行网络条件影响实验 | 2 天 |
| Week 3 | 数据整理和清洗 | 2 天 |
| Week 4 | 数据分析和绘图 | 3 天 |
| Week 4 | 撰写实验报告 | 4 天 |

---

## 10. 预期实验结果

基于理论分析和代码实现，预期结果：

1. **拜占庭容错阈值验证**
   - f/n < 1/3 时，共识成功率 > 95%
   - f/n = 1/3 时，成功率约 60-80%
   - f/n > 1/3 时，系统可能失效

2. **性能特征**
   - 端到端延迟主要来自 LLM 推理（> 70%）
   - 消息复杂度接近 O(n²)（PBFT 特性）
   - 视图切换会显著增加延迟

3. **LLM 协同效果**
   - 使用真实 LLM（zhipu, openai）时准确率 > 90%
   - 多 Agent 协作可能略优于单 Agent（因交叉验证）

4. **可扩展性**
   - Agent 数量增加时，延迟线性增长
   - 消息数量呈平方增长

---

## 附录：快速开始指南

### A.1 环境准备

```bash
# 克隆代码（如果还没有）
cd /path/to/ex-code/bft4agent-simple

# 安装依赖
pip install -r requirements.txt

# 配置 LLM API Key（如果使用真实 LLM）
cp config.example.yaml config.yaml
vim config.yaml  # 编辑配置
```

### A.2 运行第一个实验

```bash
# 使用 Mock LLM 快速测试
python main.py

# 预期输出: 3 个数学任务的成功共识过程
```

### A.3 查看结果

```bash
# 查看日志
cat experiment_*.log

# 查看保存的 JSON 结果（如果启用）
ls data/results/
```

---

**文档版本**: v2.0 (基于代码实现重写)
**最后更新**: 2025-01-28
**作者**: BFT4Agent 项目组
**对应代码版本**: bft4agent-simple v1.0
